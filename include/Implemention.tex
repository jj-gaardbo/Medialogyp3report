\chapter{Implemention}
	\section{DLLs and Unity}
		When discussing the initial idea at the semester workshop it was suggested that we implement the design in the Unity game engine\footnote{Unity's homepage \url{https://unity3d.com/}}, as it allows for high-level management of objects in space, and would reduce development time on the part of the implementation not concerned with image processing. Unity has a fair number of different options for performing image processing. However, as we would be creating the fiducial markers from scratch we could not use any preexisting software. We were already familiar with openCV, a fast library for image processing and computer vision, so developing using openCV made sense.\\\\
		One issue is that Unity uses C\# and openCV is developed for C++, C, Python, and Java. A way to bridge this language barrier is to compile the C++ code as a DLL (dynamic linked library), and import it into the C\# code. DLLs  cannot be executed in the way normal applications are, and are instead designed to be used by other applications. Because they can be complied from a host of different languages they are not limited to what C\# code can do. Another advantage is that they are compiled in machine code and are therefore very fast\footnote{How to Write Native Plugins For Unity \url{https://www.alanzucconi.com/2015/10/11/how-to-write-native-plugins-for-unity/}}. However, there are a number of disadvantages with this implementation. As Unity and the plug-in do not have access to each other's code, passing an object between the two is difficult, for example. For the same reason, debugging crashes is tricky. One fatal bug we had to solve happened in an unmanaged part of Unity, so Unity could not give an error message, and the code developed in C++ had no console where a log could be printed.\\\\
		Importing a function into DLL is simple, as seen in Listing \ref{listing:dllExport}.
\begin{listing}[H]
	\caption{How to: declare a function for DLL export}
	\label{listing:dllExport}
	\begin{minted}[frame=lines, framesep=2mm,baselinestretch=1.1,fontsize=\footnotesize,linenos]{cpp}
	extern "C" __declspec( dllexport ) int MyFunc(long parm1);
	\end{minted}
\end{listing}
\codeword{extern "C"} tells the compiler that the function name should not be changed when it is compiled, so that its name is known when it is being imported into Unity. \codeword{__declspec()} tells the linker to do something. In this case \codeword{dllexport}, which tells it that it should export a function to a DLL. Therefore \codeword{__declspec(dllimport)} will be used to import the function in Unity. A sample call might look like this\\
\begin{listing}[H]
	\caption{How to: declare a function for DLL import}
	\label{listing:dllImport}
	\begin{minted}[frame=lines,
	framesep=2mm,baselinestretch=1.1,fontsize=\footnotesize,linenos]{cpp}
[DllImport("unityOpencvPlugin", EntryPoint = "init")]
public static extern int Init(ref int outCameraWidth, ref int outCameraHeight);
	\end{minted}
\end{listing}
One provides the name of the DLL where Unity will look for a function called \codeword{init}. This is why it is important that the function name is not changed when exporting. In line 2 a function is declared that will call the imported function. Do note that this function must have the same signature (return type and arguments), Unity cannot check, so it trusts that things are as they should be. Signature compatibility is sensible and easy for primitive types like \codeword{int}, however for objects it is a bit more tricky. It requires you to declare similar objects in both languages, with variables in the same order. Otherwise the data wont make sense when returned. As an example, we need to return the markers found after image processing. They are represented in a structure. 
\begin{listing}[H]
	\caption{Objects in C\# and C++}
	\label{listing:objects}
	\begin{minted}[frame=lines, framesep=2mm,baselinestretch=1.1,fontsize=\footnotesize,linenos]{c++}
			//in C++
struct ObjectData{
ObjectData(int x, int y, int type, int color) : X(x), Y(y), Type(type), Color(color) {}
int X, Y, Type, Color;
};
			//in C#	
[StructLayout(LayoutKind.Sequential, Size = 16)]
public struct CVObject{
public int X, Y, Type, Color;
}
	\end{minted}
\end{listing}
In Unity the structure needs to be laid out sequentially when exported to unmanaged memory.\footnote{Unity layout\url{https://msdn.microsoft.com/en-us/library/system.runtime.interopservices.layoutkind(v=vs.110).aspx}}. If you need to detect several objects it is easier to pass a pointer to an array, and have C++ fill it out from it code. A few things are needed for this to work. The function needs to take a pointer as an argument, and one also needs to pass the size of the array as an argument, so  that the method does not overwrite data outside of the array. The memory that the pointer points to must not remain static, or the pointer would no longer point to the right data. In C\# the keyword \codeword{Fixed}Â prevents data from being moved in memory, and \codeword{unsafe} allows you to work with pointers. Here is an example of how we implemented this.
\begin{listing}[H]
 	\caption{The function call to pass a pointer to C++, which is filled by the code}
 	\label{listing:pointer}
 	\begin{minted}[frame=lines,
 		framesep=2mm,baselinestretch=1.1,fontsize=\footnotesize,linenos]{c++}
unsafe{
	fixed (CVObject* outMarkers = _markers){
		Cap(outMarkers, _maxMarkerDetectCount, ref detectedMarkersCount);
	}
}
 	\end{minted}
\end{listing}