\chapter{Implemention}
	\section{DLL's and Unity}
		When we presented our idea at the semester workshop it was suggested that we implement the design in the Unity game engine\footnote{Unity's homepage \url{https://unity3d.com/}}, as it allow for high-level management of objects in space, and would notably reduce development time on the non-image processing part of the implementation. Unity has a fair amount of different options for doing image processing. However, as we would be creating the fiducial markers from scratch we could not use any preexisting software. From the study we were familiar with openCV, a library used for computer vision that is renowned for its speed, so it made sense to implement using that\\\\
		It's a great idea, and really there is only one problem. Unity uses C\# and openCV uses C++. The suggested way to breach this language barrier is to compile the C++ code as a dll(dynamic linked library), and import it into the C\# code. dll's  cannot be executed in the way normal applications are, an instead are designed to be used by other applications. Because they can be complied from a host of different languages they are not limited to what C\# code can do. Another advantage is that they are compiled in machine code and therefore are blazing fast\footnote{How to Write Native Plugins For Unity \url{https://www.alanzucconi.com/2015/10/11/how-to-write-native-plugins-for-unity/}}. However, there are a bunch of disadvantages with this implementation. Unity and the plug-in do not have access to each others code, for instance passing object between the two proved difficult. For the same reason figuring out what caused a crash often proved arduous as the crash happened in an unmanaged part of Unity, Unity could not give an error message, and the C++ code had no console were one could print data.\\\\
		Importing a function into dll is pretty easy though, as seen in Listing \ref{listing:dllExport}.
\begin{listing}[H]
	\caption{How to: declare a function for dll export}
	\label{listing:dllExport}
	\begin{minted}[frame=lines, framesep=2mm,baselinestretch=1.1,fontsize=\footnotesize,linenos]{cpp}
	extern "C" __declspec( dllexport ) int MyFunc(long parm1);
	\end{minted}
\end{listing}
Extern "C" tell the compiler that the function name should not be changed when it is compiled, so that its name is known when it is being imported into unity. \_\_declspec(), tells the linker to do something. In this case dllexport, which tells it that it should export a function to a dll. Correspondingly \_\_declspec(dllimport) will be used to import the function in Unity. A sample call might look like this\\
\begin{listing}[H]
	\caption{How to: declare a function for dll import}
	\label{listing:dllImport}
	\begin{minted}[frame=lines,
	framesep=2mm,baselinestretch=1.1,fontsize=\footnotesize,linenos]{cpp}
[DllImport("unityOpencvPlugin", EntryPoint = "init")]
public static extern int Init(ref int outCameraWidth, ref int outCameraHeight);
	\end{minted}
\end{listing}
One provides the name of the dll where Unity will look for a function called init. This is why it is important that the function name is not changed when exporting. In line 2 a function is declared that will call the imported function. Do note that this function has to have the same signature(return type, and arguments), Unity cannot check so it has to trust you on this. Obviously signature compatibility makes sense and is easy for primitive types like int, however for objects it is a bit more tricky. It requires you to declare similar objects in both languages, with variables in the same order. Otherwise the data wont make sense when returned. Real life example, we need to return the markers found during image processing. They are represented in a structure. 
\begin{listing}[H]
	\caption{Objects in C\# and C++}
	\label{listing:objects}
	\begin{minted}[frame=lines, framesep=2mm,baselinestretch=1.1,fontsize=\footnotesize,linenos]{c++}
			//in C++
struct ObjectData{
ObjectData(int x, int y, int type, int color) : X(x), Y(y), Type(type), Color(color) {}
int X, Y, Type, Color;
};
			//in C#	
[StructLayout(LayoutKind.Sequential, Size = 16)]
public struct CVObject{
public int X, Y, Type, Color;
}
	\end{minted}
\end{listing}
In Unity the structure needs to be laid out sequentially when exported to unmanaged memory.\footnote{Unity layout\url{https://msdn.microsoft.com/en-us/library/system.runtime.interopservices.layoutkind(v=vs.110).aspx}}. If you need to detect several objects it is easier to pass a pointer to an array, and have C++ fill it out from it code. For this to work you need a few things. Obviously the function needs to take a pointer as an argument, you also need to pass the size of the array as an argument so the method do not overwrite data outside of the array. lastly the memory that the pointer points to must not remain static, otherwise the pointer will no longer point to the right data. In C\# the keyword Fixed prevents data from being moved in memory, and unsafe allows you to work with pointers. Here is an example of how we implemented this.
\begin{listing}[H]
 	\caption{The function call to pass a pointer to C++, which is filled by the code}
 	\label{listing:pointer}
 	\begin{minted}[frame=lines,
 		framesep=2mm,baselinestretch=1.1,fontsize=\footnotesize,linenos]{c++}
unsafe{
	fixed (CVObject* outMarkers = _markers){
		Cap(outMarkers, _maxMarkerDetectCount, ref detectedMarkersCount);
	}
}
 	\end{minted}
\end{listing}